<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/microwork.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/yamalight/microwork.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/microwork.js~Microwork.html">Microwork</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sleep">sleep</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">plugins</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HardwareStat">HardwareStat</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HealthCheck">HealthCheck</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SubscriberStats">SubscriberStats</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/microwork.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import amqp from &apos;amqplib&apos;;
import uuid from &apos;uuid&apos;;
import sleep from &apos;./sleep&apos;;
import createLogger from &apos;./logger&apos;;
import winston from &apos;winston&apos;;

/**
 * Core Microwork class that provides a way to create new microservice
 */
export class Microwork {
    /**
     * Microwork class construct
     * @param  {object} opts                    Microwork instance options
     * @param  {string} opts.host               RabbitMQ host to use
     * @param  {string} opts.exchange           RabbitMQ exchange to use
     * @param  {Number} opts.reconnectTimeout   Timeout before trying to reconnect to RabbitMQ on failure
     * @return {void}
     * @example
     * const service = new Microwork({host: &apos;localhost&apos;, exchange: &apos;test.exchange&apos;});
     */
    constructor({
        host = &apos;localhost&apos;,
        exchange = &apos;microwork.default.exchange&apos;,
        reconnectTimeout = 5000,
        loggingTransports,
    }) {
        // init logger
        this.initLogger(loggingTransports);
        // log
        this.logger.debug(&apos;construct with&apos;, host, exchange);
        /**
         * Service unique ID
         * @type {string}
         */
        this.id = uuid.v4();
        /**
         * RabbitMQ host address
         * @type {string}
         */
        this.host = host;
        /**
         * RabbitMQ exchange name
         * @type {string}
         */
        this.exchange = exchange;
        /**
         * Active route handlers and queues
         * @type {Object}
         */
        this.routeHandlers = {};
        /**
         * Connecting indicator
         * @type {Boolean}
         * @private
         */
        this.connecting = false;
        /**
         * Connection to RabbitMQ instance
         * @type {Object}
         * @private
         */
        this.connection = undefined;
        /**
         * Connection to RabbitMQ instance
         * @type {Object}
         * @private
         */
        this.channel = undefined;
        /**
         * Reconnect timeout reference
         * @type {Number}
         * @private
         */
        this.reconnect = undefined;
        /**
         * Reconnect timeout timer stored for later usage
         * @type {Number}
         */
        this.reconnectTimeout = reconnectTimeout;
        // init connection
        this.connect().catch(this.tryReconnect.bind(this));
    }

    /**
     * Initialize logger with new options
     * @param  {Object} transports   Logger options, see winston.js for reference
     * @return {void}
     * @private
     */
    initLogger(transports = []) {
        if (transports.length === 0) {
            // only show info in production mode
            let level = process.env.NODE_ENV === &apos;production&apos; ? &apos;info&apos; : &apos;debug&apos;;
            // only show erros in test mode
            /* istanbul ignore if  */
            if (process.env.NODE_ENV === &apos;test&apos;) {
                level = &apos;error&apos;;
            }
            transports.push(new winston.transports.Console({level}));
        }
        /**
         * Logger
         * @private
         */
        this.logger = createLogger(transports);
    }

    tryReconnect(e) {
        if (e.code === &apos;ECONNREFUSED&apos; &amp;&amp; !this.reconnect) {
            this.logger.info(`Couldn&apos;t connect to rabbit, retrying in ${Math.floor(this.reconnectTimeout / 1000)}s...`);
            this.connecting = false;
            this.reconnect = setTimeout(() =&gt; {
                this.reconnect = undefined;
                this.connect(true).catch(this.tryReconnect.bind(this));
            }, this.reconnectTimeout);
            return;
        }
        this.logger.error(&apos;Error connecting:&apos;, e);
        throw e;
    }

    /**
     * Register new Microwork plugin
     * @param  {Object} plugin      Microwork plugin object
     * @return {void}
     * @example
     * import myMicroworkPlugin from &apos;my-microwork-plugin&apos;;
     * microworkInstance.registerPlugin(myMicroworkPlugin);
     */
    registerPlugin(plugin) {
        for (const prop in plugin) {
            // only apply non-existent properties
            if (!this.hasOwnProperty(prop)) {
                /**
                 * New property from plugin
                 * @private
                 */
                this[prop] = plugin[prop];
            }
        }
    }

    /**
     * Initializes connection to RabbitMQ
     * @param  {Boolean} calledFromTimer    Defines whether function was called from reconnect timer
     * @return {Promise}                    Returns promise that can be awaited to ensure connection
     * @private
     */
    async connect(calledFromTimer = false) {
        // if not called from timer and reconnect pending - return self after delay
        if (!calledFromTimer &amp;&amp; this.reconnect) {
            return sleep(this.reconnectTimeout).then(() =&gt; this.connect());
        }
        // if connecting, wait a bit, then return self
        if (this.connecting) {
            return sleep(50).then(() =&gt; this.connect());
        }
        // do not do anything if already connected
        if (this.connection) {
            return true;
        }

        this.logger.debug(&apos;connecting...&apos;);
        // we&apos;re connecting
        this.connecting = true;
        // connect
        this.connection = await amqp.connect(`amqp://${this.host}`);
        this.logger.debug(&apos;connected to rabbit&apos;);
        // get two channels - receive and send
        this.channel = await this.connection.createChannel();
        this.logger.debug(&apos;got channels&apos;);
        // assing topic
        await this.channel.assertExchange(this.exchange, &apos;topic&apos;);
        this.logger.debug(&apos;got exchanges&apos;);
        // say we want to prefetch only 1 msg
        await this.channel.prefetch(1);
        this.logger.debug(&apos;prefetch set&apos;);
        // we&apos;re done connecting
        this.connecting = false;
    }

    /**
     * Removes existing subscription or worker.
     * If consumerTag is given only corresponding subscription will be removed.
     * Otherwise, all consumers for given topic will be terminated.
     * @param  {string} topic         Topic to remove subscription/worker from
     * @param  {string} consumerTag   Consumer tag to unsubscribe with
     * @return {Promise} Returns promise that can be awaited to ensure removal
     * @example &lt;caption&gt;Remove one subscription with consumerTag&lt;/caption&gt;
     * await microworkInstance.unsubscribe(&apos;test.topic&apos;, &apos;tag&apos;);
     * @example &lt;caption&gt;Remove all subscriptions with topic&lt;/caption&gt;
     * await microworkInstance.unsubscribe(&apos;test.topic&apos;);
     */
    async unsubscribe(topic, consumerTag) {
        // if we have consumerTag - only unsub from it
        if (consumerTag) {
            // find index
            const subIndex = this.routeHandlers[topic].findIndex(it =&gt; it.consumerTag === consumerTag);
            // cancel consuming
            await this.channel.cancel(consumerTag);
            // remove from subs
            this.routeHandlers[topic].splice(subIndex, 1);
            return;
        }
        // cancel consuming
        await Promise.all(this.routeHandlers[topic].map(it =&gt; this.channel.cancel(it.consumerTag)));
        // remove whole topic
        delete this.routeHandlers[topic];
    }

    /**
     * Stops the service, closes all workers/subscriptions and terminates the connection to RabbitMQ
     * @return {Promise} Returns promise that can be awaited to ensure termination
     * @example
     * await microworkInstance.stop();
     */
    async stop() {
        if (!this.connection &amp;&amp; this.reconnect) {
            this.logger.debug(&apos;not connected, cleaning reconnect timeout&apos;);
            clearTimeout(this.reconnect);
            return;
        }
        // cleanup queues and routes if any are present
        const paths = Object.keys(this.routeHandlers);
        if (paths.length) {
            await Promise.all(paths.map(path =&gt; this.unsubscribe(path)));
        }
        // close channel &amp; connection
        await this.channel.close();
        await this.connection.close();
    }

    /**
     * Send given data to the specified topic
     * @param  {string} topic Topic to send data to
     * @param  {Any}    data  Data to send
     * @param  {Object} opts  Publish options for RabbitMQ
     * @return {Promise}      Returns promise that can be awaited to ensure termination
     * @example
     * await microworkInstance.send(&apos;test.topic&apos;, &apos;test&apos;);
     * await microworkInstance.send(&apos;test.topic&apos;, {json: &apos;works too&apos;});
     */
    async send(topic, data = &apos;&apos;, opts = {}) {
        // wait for connection
        await this.connect();
        // send
        this.logger.debug(&apos;sending to&apos;, topic, &apos;data:&apos;, data);
        this.channel.publish(this.exchange, topic, new Buffer(JSON.stringify(data)), opts);
    }

    /**
     * Create subscription to given topic that will pass all incoming messages to given handler
     * @param  {string}   topic          Topic to subscribe to
     * @param  {Function} handler        Handler function that will get all incoming messages
     * @param  {Object}   queueConfig    Queue config to pass to RabbitMQ
     * @param  {Object}   consumeConfig  Consume config to pass to RabbitMQ
     * @param  {Object}   config         Config for subscriber (e.g. wether to auto-ack messages)
     * @return {string}                  Consumer tag that can be used for more precise unsubscribe action
     * @example &lt;caption&gt;Simple subscribe usage&lt;/caption&gt;
     * await microworkInstance.subscribe(&apos;test.topic&apos;, (msg, reply) =&gt; {
     * 	if (msg === &apos;ping&apos;) {
     * 		reply(&apos;test.reply&apos;, &apos;pong&apos;);
     * 	}
     * });
     * @example &lt;caption&gt;Subscribe with custom RabbitMQ options&lt;/caption&gt;
     * await microworkInstance.subscribe(&apos;test.topic&apos;, (msg, reply) =&gt; {
     * 	if (msg === &apos;ping&apos;) {
     * 		reply(&apos;test.reply&apos;, &apos;pong&apos;);
     * 	}
     * }, {durable: true, autoDelete: true, exclusive: true});
     * @example &lt;caption&gt;Subscribe without auto-ack&lt;/caption&gt;
     * await microworkInstance.subscribe(&apos;test.topic&apos;, (msg, reply, ack, nack) =&gt; {
     * 	if (msg === &apos;ping&apos;) {
     * 		ack();
     * 		reply(&apos;test.reply&apos;, &apos;pong&apos;);
     * 	} else {
     * 		nack();
     * 	}
     * }, {}, {}, {ack: false});
     */
    async subscribe(
        topic,
        handler,
        queueConfig = {},
        consumeConfig = {},
        config = {}
    ) {
        // merge queueConfig with defaults
        queueConfig = {
            durable: true,
            autoDelete: true,
            ...queueConfig,
        };
        // merge consumeConfig with defaults
        consumeConfig = {
            noAck: false,
            ...consumeConfig,
        };
        // merge config with defaults
        config = {
            ack: true,
            ...config,
        };
        // wait for connection
        await this.connect();
        // get queue
        this.logger.debug(&apos;adding worker for:&apos;, topic);
        const {queue} = await this.channel.assertQueue(`microwork-${topic}-queue`, queueConfig);
        await this.channel.bindQueue(queue, this.exchange, topic);
        this.logger.debug(&apos;bound queue...&apos;);
        // consume if needed
        this.logger.debug(&apos;initiating consuming...&apos;);
        // listen for messages
        const {consumerTag} = await this.channel.consume(queue, data =&gt; {
            if (!data) {
                return;
            }
            const msg = JSON.parse(data.content.toString());
            // ack
            if (config.ack) {
                this.channel.ack(data);
            }
            // pass to handler
            const reply = this.send.bind(this);
            const ack = this.channel.ack.bind(this.channel, data);
            const nack = this.channel.nack.bind(this.channel, data);
            handler(msg, reply, ack, nack);
        }, consumeConfig);
        // push to cleanup
        if (!this.routeHandlers[topic]) {
            this.routeHandlers[topic] = [];
        }
        this.routeHandlers[topic].push({
            queue,
            consumerTag,
        });
        this.logger.info(&apos;worker inited, consuming...&apos;);
        return consumerTag;
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
